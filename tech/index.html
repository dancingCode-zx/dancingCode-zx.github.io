<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>知识点归纳以及碰到的问题 | 周心的技术博客</title>
    <meta name="generator" content="VuePress 1.5.2">
    <link rel="icon" href="/spider.png">
    <link rel="manifest" href="/spider.png">
    <link rel="apple-touch-icon" href="/spider.png">
    <meta name="description" content="">
    <link rel="preload" href="/assets/css/0.styles.8aeab2b3.css" as="style"><link rel="preload" href="/assets/js/app.989c535c.js" as="script"><link rel="preload" href="/assets/js/2.7ff8fc86.js" as="script"><link rel="preload" href="/assets/js/7.787c1541.js" as="script"><link rel="prefetch" href="/assets/js/3.010371b8.js"><link rel="prefetch" href="/assets/js/4.55c34630.js"><link rel="prefetch" href="/assets/js/5.10a35ae4.js"><link rel="prefetch" href="/assets/js/6.026cb30b.js">
    <link rel="stylesheet" href="/assets/css/0.styles.8aeab2b3.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><img src="/spider.png" alt="周心的技术博客" class="logo"> <span class="site-name can-hide">周心的技术博客</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">
  首页
</a></div><div class="nav-item"><a href="/tech/" aria-current="page" class="nav-link router-link-exact-active router-link-active">
  技术文档
</a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">
  首页
</a></div><div class="nav-item"><a href="/tech/" aria-current="page" class="nav-link router-link-exact-active router-link-active">
  技术文档
</a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>知识点归纳以及碰到的问题</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/tech/#前言" class="sidebar-link">前言</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/tech/#html、css相关" class="sidebar-link">HTML、CSS相关</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/tech/#_1-三大事件" class="sidebar-link">1. 三大事件</a></li><li class="sidebar-sub-header"><a href="/tech/#_2-冒泡、捕获、默认行为" class="sidebar-link">2. 冒泡、捕获、默认行为</a></li><li class="sidebar-sub-header"><a href="/tech/#_3-元素" class="sidebar-link">3. 元素</a></li><li class="sidebar-sub-header"><a href="/tech/#_4-css-sprite" class="sidebar-link">4. CSS sprite</a></li><li class="sidebar-sub-header"><a href="/tech/#_5-doctype" class="sidebar-link">5. DOCTYPE</a></li><li class="sidebar-sub-header"><a href="/tech/#_6-src、href、-import问题" class="sidebar-link">6. src、href、@import问题</a></li><li class="sidebar-sub-header"><a href="/tech/#_7-浮动与清除浮动" class="sidebar-link">7. 浮动与清除浮动</a></li><li class="sidebar-sub-header"><a href="/tech/#_8-img的title和alt" class="sidebar-link">8. img的title和alt</a></li><li class="sidebar-sub-header"><a href="/tech/#_9-http请求与用途" class="sidebar-link">9. HTTP请求与用途</a></li><li class="sidebar-sub-header"><a href="/tech/#_10-对网站就行优化" class="sidebar-link">10. 对网站就行优化</a></li><li class="sidebar-sub-header"><a href="/tech/#_11-http状态码" class="sidebar-link">11. http状态码</a></li><li class="sidebar-sub-header"><a href="/tech/#_12-浏览器内核" class="sidebar-link">12. 浏览器内核</a></li><li class="sidebar-sub-header"><a href="/tech/#_13-html5增加了哪些，删除了哪些" class="sidebar-link">13. html5增加了哪些，删除了哪些</a></li><li class="sidebar-sub-header"><a href="/tech/#_14-html的全局属性" class="sidebar-link">14. html的全局属性</a></li><li class="sidebar-sub-header"><a href="/tech/#_15-canvas与svg区别" class="sidebar-link">15. canvas与svg区别</a></li><li class="sidebar-sub-header"><a href="/tech/#_16-div-css布局较table好处" class="sidebar-link">16. div+css布局较table好处</a></li><li class="sidebar-sub-header"><a href="/tech/#_17-渐进增强和优雅降级" class="sidebar-link">17. 渐进增强和优雅降级</a></li><li class="sidebar-sub-header"><a href="/tech/#_18-网页制作用到的图片格式" class="sidebar-link">18. 网页制作用到的图片格式</a></li><li class="sidebar-sub-header"><a href="/tech/#_19-display-none和visibility-hidden" class="sidebar-link">19. display:none和visibility:hidden</a></li><li class="sidebar-sub-header"><a href="/tech/#_20-为什么要初始化css样式" class="sidebar-link">20. 为什么要初始化css样式</a></li><li class="sidebar-sub-header"><a href="/tech/#_21-css3新特性" class="sidebar-link">21. css3新特性</a></li><li class="sidebar-sub-header"><a href="/tech/#_22-display" class="sidebar-link">22. display</a></li><li class="sidebar-sub-header"><a href="/tech/#_23-position" class="sidebar-link">23. position</a></li><li class="sidebar-sub-header"><a href="/tech/#_24-水平居中" class="sidebar-link">24. 水平居中</a></li><li class="sidebar-sub-header"><a href="/tech/#_25-垂直居中" class="sidebar-link">25. 垂直居中</a></li><li class="sidebar-sub-header"><a href="/tech/#_26-重绘和回流-重排" class="sidebar-link">26. 重绘和回流(重排)</a></li><li class="sidebar-sub-header"><a href="/tech/#_27-内核" class="sidebar-link">27. 内核</a></li><li class="sidebar-sub-header"><a href="/tech/#_28-一次url请求的过程" class="sidebar-link">28. 一次url请求的过程</a></li><li class="sidebar-sub-header"><a href="/tech/#_29-http与tcp" class="sidebar-link">29. http与tcp</a></li><li class="sidebar-sub-header"><a href="/tech/#_30-跨域" class="sidebar-link">30. 跨域</a></li></ul></li><li><a href="/tech/#js-全是学完自己的归纳总结，可能有些错误" class="sidebar-link">JS(全是学完自己的归纳总结，可能有些错误)</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/tech/#_1-数据类型" class="sidebar-link">1. 数据类型</a></li><li class="sidebar-sub-header"><a href="/tech/#_2-原型链" class="sidebar-link">2. 原型链</a></li><li class="sidebar-sub-header"><a href="/tech/#_3-变量提升、执行上下文" class="sidebar-link">3. 变量提升、执行上下文</a></li><li class="sidebar-sub-header"><a href="/tech/#_4-cookie-session-token" class="sidebar-link">4. Cookie Session token</a></li><li class="sidebar-sub-header"><a href="/tech/#_5-mvc-与-mvvm" class="sidebar-link">5. MVC 与 MVVM</a></li><li class="sidebar-sub-header"><a href="/tech/#_6-浅拷贝-深拷贝" class="sidebar-link">6. 浅拷贝 深拷贝</a></li><li class="sidebar-sub-header"><a href="/tech/#_7-防抖-节流" class="sidebar-link">7. 防抖 节流</a></li><li class="sidebar-sub-header"><a href="/tech/#_8-数组去重" class="sidebar-link">8. 数组去重</a></li></ul></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="知识点归纳以及碰到的问题"><a href="#知识点归纳以及碰到的问题" class="header-anchor">#</a> 知识点归纳以及碰到的问题</h1> <h2 id="前言"><a href="#前言" class="header-anchor">#</a> 前言</h2> <p>早就有写一个个人博客的想法了，因为平时遇到的问题或者知识点都随手记在本子上或者发在个人的QQ群，而这些消息要不就不方便随时查看，要不就一下把缓存清空了，伤脑经。这下好了，弄一个博客，还能添加到手机屏幕，妈妈再也不用担心我把东西搞丢了(以下东西纯属平时个人整理)</p> <h2 id="html、css相关"><a href="#html、css相关" class="header-anchor">#</a> HTML、CSS相关</h2> <h3 id="_1-三大事件"><a href="#_1-三大事件" class="header-anchor">#</a> 1. 三大事件</h3> <ol><li>鼠标事件: click mouseup mouseenter</li> <li>键盘事件: keyup keydown keypress</li> <li>html事件: focus select load change</li></ol> <h3 id="_2-冒泡、捕获、默认行为"><a href="#_2-冒泡、捕获、默认行为" class="header-anchor">#</a> 2. 冒泡、捕获、默认行为</h3> <ol><li>冒泡：父子元素都有click事件，当点击子元素的click事件时，父元素的click事件也会触发
<ul><li>阻止冒泡: event.stoppropation() event.cancelbubble()(IE)</li></ul></li> <li>捕获：与冒泡相反</li> <li>默认行为: 像form表单的提交等
<ul><li>阻止默认行为: event.preventDefault() return false</li></ul></li></ol> <h3 id="_3-元素"><a href="#_3-元素" class="header-anchor">#</a> 3. 元素</h3> <ol><li>行内元素: a b span img input select strong</li> <li>块元素: div ul ol li dt p</li> <li>空元素: br hr meta
<ul><li>行内元素不可以设置宽高，不独占一行。但是可以套用块级元素占一行，如span里面套div</li> <li>块元素可以设置宽高，独占一行</li></ul></li></ol> <h3 id="_4-css-sprite"><a href="#_4-css-sprite" class="header-anchor">#</a> 4. CSS sprite</h3> <ol><li>将多个小图片拼在一个图中，通过background-position获取</li> <li>优点: 减少http请求，提高页面加载速度，减少图片大小，减少内存</li> <li>缺点: 图片合并麻烦，维护麻烦，修改一个图片就要重新布局</li></ol> <h3 id="_5-doctype"><a href="#_5-doctype" class="header-anchor">#</a> 5. DOCTYPE</h3> <p>因为HTML5不在是SGML的子集，所以不在需要DTD的引入，所以开头只要写DOCTYPE，他的作用是告诉浏览器用什么文档类型的规范来解析该文档</p> <h3 id="_6-src、href、-import问题"><a href="#_6-src、href、-import问题" class="header-anchor">#</a> 6. src、href、@import问题</h3> <ol><li>src 会暂停其他资源的加载,直到把src引用的资源加载、编译、执行完(流氓),这就是为什么script标签放页面底部</li> <li>@import 和src这个流氓一样</li> <li>href 这个就很好了，加载他引入的同时，还能加载其他的资源，这也是为什么建议用herf而不用@import
<ul><li>重申web标准及wcc标准</li> <li>标签闭合 标签小写 外链css/js 结构行为为表现的分离</li> <li>(插一个知识点)前端页面三大层次 结构层(html) 表现层(css) 行为层(js)</li></ul></li></ol> <h3 id="_7-浮动与清除浮动"><a href="#_7-浮动与清除浮动" class="header-anchor">#</a> 7. 浮动与清除浮动</h3> <ol><li>浮动:浮动的框可以向左向右移动，直到触碰到外部包含的边框或另一个浮动的边框</li> <li>清除浮动:脱离普通的文档流
<ul><li>clear:both 在最后一个标签再加一个标签，加上这个属性</li> <li>overflow:hidden 父级添加这个属性，触发BFC模式(块格式化上下文)，缺点：容易导致内容被隐藏</li> <li>after伪元素(.clearfix是父级的)</li></ul></li></ol> <div class="language- extra-class"><pre class="language-text"><code>  .clearfix:after {
    content:&quot;&quot;;
    display:block;
    clear:both;
    visibility:hidden;
  }
  .clearfix {
    *zoom:1; 兼容IE
  }
</code></pre></div><ul><li>before、after双伪元素清除<div class="language- extra-class"><pre class="language-text"><code>  .clearfix:before, .clearfix:after {
    content:&quot;&quot;;
    display:table;
  }
  .clearfix:after {
    clear:both;
  }
  .clearfix {
    *zoom:1;
  }
</code></pre></div></li></ul> <h3 id="_8-img的title和alt"><a href="#_8-img的title和alt" class="header-anchor">#</a> 8. img的title和alt</h3> <ol><li>alt: 图片无法加载显示的文字</li> <li>title: 图片正常加载，移动到图片上显示的文字</li></ol> <h3 id="_9-http请求与用途"><a href="#_9-http请求与用途" class="header-anchor">#</a> 9. HTTP请求与用途</h3> <ol><li>get: 发送请求来获得服务器的资源</li> <li>post: 提交数据，指定资源在服务器位置，相比于    get,携带的体积大</li> <li>put: 提交资源，不能指定位置</li> <li>delect: 删除服务器资源</li></ol> <h3 id="_10-对网站就行优化"><a href="#_10-对网站就行优化" class="header-anchor">#</a> 10. 对网站就行优化</h3> <ol><li>content: 减少http请求，合并文件，精灵图，减少dom数量</li> <li>server: 对组件进行Gzip压缩</li> <li>cookie: 减少cookie大小</li> <li>css： 将样式放页面顶部，用link并不用@import</li> <li>js: 脚本放底部，压缩js，减少DOM</li> <li>图片: base64,精灵图</li></ol> <h3 id="_11-http状态码"><a href="#_11-http状态码" class="header-anchor">#</a> 11. http状态码</h3> <ol><li>1xx: 信息状态码</li> <li>2xx: 成功状态码
<ul><li>200 ok,正确返回信息</li> <li>201 请求成功，并且服务器创建了新的资源</li> <li>202 服务器接收请求，但没有处理</li></ul></li> <li>3xx 重定向
<ul><li>301 永久重定向</li> <li>302 临时重定向</li> <li>303 临时重定向，且总是用get请求</li></ul></li> <li>4xx 服务器错误
<ul><li>400 服务器无法理解请求的格式</li> <li>401 请求未授权</li> <li>403 禁止访问</li> <li>404 找不到资源</li></ul></li> <li>5xx
<ul><li>500 服务器端错误</li> <li>503 服务器维护中</li></ul></li></ol> <h3 id="_12-浏览器内核"><a href="#_12-浏览器内核" class="header-anchor">#</a> 12. 浏览器内核</h3> <ol><li>渲染引擎: 取得网页(html)内容，加入css</li> <li>js引擎: 解析和执行JS来实现网页动态效果</li></ol> <h3 id="_13-html5增加了哪些，删除了哪些"><a href="#_13-html5增加了哪些，删除了哪些" class="header-anchor">#</a> 13. html5增加了哪些，删除了哪些</h3> <ol><li>绘画canvas</li> <li>媒体audio、vedio</li> <li>存储localstorage、sessionstorage</li> <li>语义化标签head nav footer article section</li> <li>表单控件calendae data email number</li> <li>新技术websocket webworker</li> <li>移除:font big center frame</li></ol> <h3 id="_14-html的全局属性"><a href="#_14-html的全局属性" class="header-anchor">#</a> 14. html的全局属性</h3> <ol><li>class 设置类</li> <li>id 文档内唯一</li> <li>style 行内css样式</li> <li>title 元素相关的信息</li> <li>data 自定义属性</li></ol> <h3 id="_15-canvas与svg区别"><a href="#_15-canvas与svg区别" class="header-anchor">#</a> 15. canvas与svg区别</h3> <ol><li>svg: 绘制的每一个图形都是独立的dom节点,可以绑定事件</li> <li>canvas: 输出的是一块画布</li> <li>不同: canvas是画布，放大会失帧，锯齿。svg是矢量图形,可以修改参数来缩放，不失帧</li></ol> <h3 id="_16-div-css布局较table好处"><a href="#_16-div-css布局较table好处" class="header-anchor">#</a> 16. div+css布局较table好处</h3> <ol><li>修改方便，只要改css文件</li> <li>页面加载速度块，结构清晰</li> <li>结构、表现分离</li> <li>易优化、seo</li></ol> <h3 id="_17-渐进增强和优雅降级"><a href="#_17-渐进增强和优雅降级" class="header-anchor">#</a> 17. 渐进增强和优雅降级</h3> <ol><li>渐进增强: 针对低版本浏览器构建页面，保证最基本的功能，然后对高版本浏览器进行效果、交互等功能的添加</li> <li>优雅降级: 一开始就构建完整功能，然后针对低版本浏览器进行兼容</li> <li>区别: 优雅降级是从复杂开始，减少用户体验。而渐进增强是从基础开始扩充，增加用户体验。</li></ol> <h3 id="_18-网页制作用到的图片格式"><a href="#_18-网页制作用到的图片格式" class="header-anchor">#</a> 18. 网页制作用到的图片格式</h3> <p>jpg png jpeg svg webp(体检小，质量高，iphone不能用) Apng</p> <h3 id="_19-display-none和visibility-hidden"><a href="#_19-display-none和visibility-hidden" class="header-anchor">#</a> 19. display:none和visibility:hidden</h3> <ol><li>display:none: 删除这个dom 和v-if一样</li> <li>visibility:hidden: 修改css样式，使其不可见，继承属性，子元素要可见要修改样式(v-show)</li></ol> <h3 id="_20-为什么要初始化css样式"><a href="#_20-为什么要初始化css样式" class="header-anchor">#</a> 20. 为什么要初始化css样式</h3> <p>不同的浏览器对一些标签的默认值不同，为了让页面在任何一个浏览器显示的效果一样，就要初始化样式</p> <h3 id="_21-css3新特性"><a href="#_21-css3新特性" class="header-anchor">#</a> 21. css3新特性</h3> <ol><li>新增各种选择器</li> <li>圆角 border-radius</li> <li>渐变</li> <li>阴影text-shadow box-shadow</li> <li>动画animation:@keyframes</li> <li>过渡transition 属性 时间 函数(匀速，快慢快) 延迟</li> <li>transform rotate(旋转) scale(缩放) translate(移动) 3d父级要加透明属性perspective</li></ol> <h3 id="_22-display"><a href="#_22-display" class="header-anchor">#</a> 22. display</h3> <ol><li>block: 变成块级元素</li> <li>inline: 变行内元素</li> <li>none: 不可见</li> <li>table: 像表格一样显示</li> <li>inline-block: 行内块级</li> <li>inherit: 从父级继承display值</li></ol> <h3 id="_23-position"><a href="#_23-position" class="header-anchor">#</a> 23. position</h3> <ol><li>absolute: 绝对，相对于外面第一个父元素</li> <li>fixed: 绝对，相对于浏览器窗口</li> <li>relative: 相对，相对于本身</li> <li>inherie: 从父元素继承</li></ol> <h3 id="_24-水平居中"><a href="#_24-水平居中" class="header-anchor">#</a> 24. 水平居中</h3> <ol><li>行内元素: 设置text-align：center</li> <li>宽度固定: 左右margin:auto</li> <li>绝对定位： 上下左右0 margin：auto</li> <li>flex布局: justify-content:center</li></ol> <h3 id="_25-垂直居中"><a href="#_25-垂直居中" class="header-anchor">#</a> 25. 垂直居中</h3> <ol><li>绝对定位: 上下0 margin:auto</li> <li>flex布: align-items:center</li> <li>文本: line-height:height</li></ol> <h4 id="垂直水平居中"><a href="#垂直水平居中" class="header-anchor">#</a> 垂直水平居中</h4> <div class="language- extra-class"><pre class="language-text"><code>&lt;style&gt;
  html,body{
    height:100%;
  }
  #box{
    box-sizing: border-box;
    height: 50px;
    width: 100px;
  }
&lt;/style&gt;

&lt;body&gt;
  &lt;div id=&quot;box&quot;&gt;&lt;/div&gt;
&lt;/body&gt;
</code></pre></div><ul><li>定位方法</li></ul> <ol><li>让他在屏幕中间，然后左移一半，上移一半，这必须要知道宽高</li></ol> <div class="language- extra-class"><pre><code>```
body{
  position:relative;
}
#box{
  position:absolute;
  top: 50%;
  left: 50%;
  margin-top: -25px;
  margin-left: -50px;
}
```

2. 这个是必须要有宽高
```
body{
  position:relative;
}
#box{
  position:absolute;
  top: 0;
  left: 0;
  right:0;
  bottom:0;
  margin:auto;
}
```

3. css3
```
body{
  position:relative;
}
#box{
  position:absolute;
  top: 50%;
  left: 50%;
  transform:transition(-50%，-50%)
}
```

- flex，让body里面的内容居中
 ```
  body{
    display:flex;
    align-items: center;
    justify-content: center;
  }
 ```
 
- JS 前提父元素 realtive
```
&lt;script&gt;
  let win = document.documentElement
  winH =win.clientHeight
  winW = win.clientWidth


  boxH=box.offsetHeight
  boxW=box.offsetWidth

  box.style.position=&quot;absolute&quot;
  box.style.top=(winH-boxH)/2 + 'px'
  box.style.left=(winW-boxW)/2 + 'PX'
&lt;/script&gt;
```
</code></pre></div><h3 id="_26-重绘和回流-重排"><a href="#_26-重绘和回流-重排" class="header-anchor">#</a> 26. 重绘和回流(重排)</h3> <ol><li>重排: dom的变化影响到元素的几何属性，浏览器重新计算元素的几何属性，其他元素的几何属性也会受到影响，浏览器就要重新构造渲染树，这就叫重排。</li> <li>重绘: 浏览器受到影响的部分重新绘制到屏幕上的过程</li> <li>引起重排的原因
<ul><li>添加或删除可见的dom</li> <li>元素位置内容尺寸改变</li> <li>页面初始化</li> <li>浏览器窗口尺寸改变</li></ul></li> <li>重排一定重绘，重绘不一定重排</li></ol> <h3 id="_27-内核"><a href="#_27-内核" class="header-anchor">#</a> 27. 内核</h3> <ol><li>火狐   -moz-</li> <li>IE     -ms-</li> <li>opera  -o-</li> <li>chrome safar -webkit-</li></ol> <h3 id="_28-一次url请求的过程"><a href="#_28-一次url请求的过程" class="header-anchor">#</a> 28. 一次url请求的过程</h3> <ul><li>域名解析 --&gt; 发起TCP的3次握手 --&gt; 建立TCP连接后发起http请求 --&gt; 服务器响应http请求，浏览器得到html代码 --&gt; 浏览器解析html代码，并请求html代码中的资源（如js、css、图片等） --&gt; 浏览器对页面进行渲染呈现给用户</li></ul> <ol><li>域名解析   当我们访问www.baidu.com时，首先浏览器会先解析这个域名(主机)的IP地址
先是浏览器看自身的dns缓存，看有没有对应的IP地址，有且没过期就进入2，没有就查找操作系统的dns缓存，看有没有，有且没过期也进入2，还没找到查找host文件夹，有没过期进入2，没有就请求运营商的dns缓存，让他给你。</li> <li>TCP连接通过三次握手建立，释放通过四次挥手。  什是三次握手？当你去要一个女孩子微信的时候，你说：“美女，能加个微信吗？”，女孩子打量了你一眼，能接收你的长相的时候，就问“你有钱吗？你有车吗？你有房吗？”，然后你说说并拿出证据，那么恭喜你，勾搭成功了，然后过起了没羞没臊的生活。</li> <li>发送http请求  如我们要打开www.baidu.com, 客户端就向服务端请求访问这个页面</li> <li>服务端响应这个页面，客户端就能得到请求的资源，如www.baidu.com的html代码。就像女孩子觉得你长得还可以，还有钱时，就把微信给你了。</li> <li>客户端解析请求到的资源，如解析html代码，并请求html代码里的资源如图片等。就像你知道了女孩子的微信，你知道他的三围吗？还得厚着脸皮继续问嘛？(有感觉自己是老司机)</li> <li>当上面的工作做完后，浏览器就能把这个页面呈现在我们眼前了。</li></ol> <h3 id="_29-http与tcp"><a href="#_29-http与tcp" class="header-anchor">#</a> 29. http与tcp</h3> <ol><li>TCP 运输层协议 传输数据</li> <li>http 应用层协议 怎么传输数据</li></ol> <h3 id="_30-跨域"><a href="#_30-跨域" class="header-anchor">#</a> 30. 跨域</h3> <ol><li></li></ol> <h2 id="js-全是学完自己的归纳总结，可能有些错误"><a href="#js-全是学完自己的归纳总结，可能有些错误" class="header-anchor">#</a> JS(全是学完自己的归纳总结，可能有些错误)</h2> <h3 id="_1-数据类型"><a href="#_1-数据类型" class="header-anchor">#</a> 1. 数据类型</h3> <ol><li>基本数据类型: string  number  boolean  null  undefined</li> <li>引用数据类型: object  function  Array</li> <li>function: 特殊的对象，存储可执行的代码</li> <li>Array: 特殊的对象，里面的数据有序，可以通过下标查找</li> <li>数据类型判断方法
<ul><li>type of: 返回数据类型的字符串表达，即</li></ul> <div class="language- extra-class"><pre class="language-text"><code>  var a
  console(a)  // undefined
  type of(a)  //'undefined'
</code></pre></div>可以判断String undefined boolean number
<ul><li>==/=== 前者会先转换类型在判断是否相等，后者直接判断<br>
null通过===判断<br>
意思就是基本数据类型除null用===判断之外，其余都可以用 type of判断</li> <li>instance of: A instance of B  B的显示原型是否在A的原型链上，在返回ture<br>
引用数据类型都可以通过他判断</li></ul></li></ol> <h3 id="_2-原型链"><a href="#_2-原型链" class="header-anchor">#</a> 2. 原型链</h3> <ol><li><code>function person(){}</code><br> <code>var a = new person()</code> <ul><li>构造函数有一个prototype属性</li> <li>实例对象有一个__proto__属性(尼玛，咋画图，不画图谁搞得清！！！)</li> <li>每个原型都有一个 constructor 属性指向关联的构造函数 实例原型指向构造函数 person.prototype.constructor=person</li> <li>构造函数的prototype指向一个空的object对象(这个空object对象也有一个__proto__属性，指向顶级object对象，祖宗，上面没人了，在__proto__ = null)</li> <li>实列的__proto__也指向这个空的object对象(这个空object对象也有一个__proto__属性，指向顶级object对象，祖宗，上面没人了，在__proto__ = null)<br>
意思就是 <code>person.prototype = a.__ proto __</code><br>
当我们<code>var a = new person()</code>时发生了什么呢?</li></ul> <div class="language- extra-class"><pre class="language-text"><code>  var a = {}   
  a.__proto__ = person.prototype  //person.call(a)
</code></pre></div>一目了然，先定义一个空对象，然后让创建的a的__proto__ 指向 person 的prototype<br>
当我们给person的prototype赋值会怎么样呢？<br> <code>person.prototype.number = 12</code><br>
显然 <code>a.__proto__.num = 12</code> //不是复制，是指向同一个对象，读值
而上文提到他们指向的空object对象的__proto__指向顶级object对象，就是那个祖宗。讲道理，祖宗就一个哈，事实祖宗就是一个，那么就是<br> <code>person.prototype.__proto__.age = 108</code><br>
那么，可以得出一个结论  <code>a.__proto__.__proto__.age = 108</code>  //读取这个age<br>
问题来了，程序员不就是为了偷懒嘛！！！不然干嘛封装一个个对象、方法(其实，这个是我现在还没搞懂)<br>
那些烦人的__proto__就给省略了，什么意思呢？下面进入有奖竞猜环节，中奖自理<div class="language- extra-class"><pre class="language-text"><code>  var a = new b()
  b.prototype.num = 12
  b.prototype.__proto__.age = 108
</code></pre></div>那么问题来了<code>a.num = ? a.age = ?</code>
给点提示偷懒。。。。。。
下面公布答案，拿小本本画画吧<br>
—————————————————————————————————————
—————————————————————————————————————<br>
————————————煞费苦心的分割线——————————
—————————————————————————————————————<br>
—————————————————————————————————————<br>
根据偷懒算法，显然<code>a.num = 12 a.age = 108</code>
终极大招，Function也是一个函数，他也是new Function产生的<br>
Object也是一个函数,也是 new Function产生的，即<br> <code>Function = new Function() Object = new Function()</code><br>
此外，有句话叫做万物皆对象<br> <code>Function = new Object() Object = new Object()</code>
根据这几句代码，可以得出<div class="language- extra-class"><pre class="language-text"><code>Function.__proto__ = Function.prototype   
Object.__proto__ = Function.prototype   

Function.__proto__ = Object.prototype   
Object.__proto__ = Object.prototype   
</code></pre></div></li></ol> <h3 id="_3-变量提升、执行上下文"><a href="#_3-变量提升、执行上下文" class="header-anchor">#</a> 3. 变量提升、执行上下文</h3> <ol><li>当一个页面被加载时会发生什么呢？</li></ol> <ul><li>首先--&gt;页面被加载--&gt;创建windows全局对象--&gt;生成全局作用域--&gt;生成执行上下文--&gt;变量提升--&gt;生成全局变量对象
<ul><li>在执行全局代码之前，先将windows确定为全局执行上下文</li> <li>var 定义的全局变量和函数，添加到windows上为windows的属性，并赋值为null<br>
即 ```
console.log(a)<br>
var a=3
得到的结论是 undefined，即  console.log(a) ==&gt; undefined<div class="language- extra-class"><pre class="language-text"><code>这其中涉及到什么呢   
根据上文所说，先将windows确定为执行上下文   
然后 var  定义的变量，赋值为undefined, 且在windows上   
可以这样理解   
</code></pre></div>var a;
console.log(a);
a=3;<div class="language- extra-class"><pre class="language-text"><code>看到上面的代码可以知道 定义了a，但是喂赋值，所以为undefined   
所以```
console.log(fn)
var fn = function(){
  console.log('a')
}
</code></pre></div>这里<code>console.log(fn)</code>是什么呢？<br>
根据上面所说，是 undefined<br>
那么函数声明呢？函数声明和函数定义有什么区别？<div class="language- extra-class"><pre class="language-text"><code>console.log(gn)   
function gn(){
  console.log('b')
}
console.log(gn)==&gt;function gn(){
  console.log('b')
}
</code></pre></div>windows会把函数声明的所有数据添加到他的属性里<br>
所以可以通过windows获取<br>
console.log(windows.a) = 3<br>
并且函数提升是优先于变量提升的<br>
看下面这段代码<div class="language- extra-class"><pre class="language-text"><code>  console.log(a)  //f a(){console.log('11111)}  这里不是undefined的原因就是函数提升优先于变量提升
  console.log(a()) // undefined
  var a = 3
  function a(){
    console.log('11111')
  }
  console.log(a)  //3
  a=6
  console.log(a()) //a is not a function  这里被覆盖了，上一句代码赋值了
</code></pre></div>原理<div class="language- extra-class"><pre class="language-text"><code>  var a = function(){
    console.log('11111')
  }
  var a
  console.log(a)
  console.log(a())

  a=3
  console.log(a) //3
  a=6
  console.log(a()) // a is not a function
</code></pre></div>函数提升优先级比变量提升优先级高，不会被变量声明覆盖。但会被变量赋值覆盖</li></ul></li></ul> <h3 id="_4-cookie-session-token"><a href="#_4-cookie-session-token" class="header-anchor">#</a> 4. Cookie Session token</h3> <ul><li>由于Http是无状态信息的(当时的硬件与效率原因)，无法保存信息，而随着用户需求的增加，与服务器效率，用cokie session token来记录信息
<ul><li>cookie 明文 保存在客户端，不消耗服务器资源，不安全，是一个在硬盘的文件，有缓存作用，用来 存一些不敏感的消息</li> <li>客户端发送信息(账号，密码),正确且用了session技术的话服务器会发送一个包含sesion id的cookie给客户端，客户端下次进入，向服务端发送这个cookie，如果服务端的session id 有这一个就成功了(cookie可以单独使用，sesson必须配合cookie使用)，最大的缺点就是服务器要记录session id，在现在，一些app的人数爆炸，如果存几万个，几十万个，就得返回500了</li> <li>token 不存储  会把header头以及保存用户信息得俩部分通过某种算法变成一个签名（加密后得一种验证码），在加密变成一串字符串。验证时解析这个字符串，得到header以及保存得信息部分及签名，在比较俩签名是否相同，相同那么header与信息是正确的</li></ul></li></ul> <h3 id="_5-mvc-与-mvvm"><a href="#_5-mvc-与-mvvm" class="header-anchor">#</a> 5. MVC 与 MVVM</h3> <ol><li>MVC model + view + controller MVC的思想：一句话描述就是Controller负责将Model的数据用View显示出来
<ul><li>model 数据存放的地方，提供接口供controller使用</li> <li>controller c处理应用程序中用户交互的部分 从视图层读取存在模型层，或者从模型层读取，渲染到视图层</li> <li>view 能看到的，一般都是模型层的数据<br>
view 与 model是单向的，不会直接交互，必须通过controller</li></ul></li> <li>MVVM 以前，由于页面功能的操作不是那么的频繁，所以mvc完全应付的过来。而随着功能逐渐的丰富，view或model频繁的更改，dom被频繁的操作，controller就有点力不从心了。为了解决这个问题，就出现了MVVM，MV还是熟悉的配方，管理者自己的事，而区别就是VM,他能沟通MV，通过数据绑定将model转化为view,通过事件监听将view转化为model,从而对数据进行双向数据绑定(vue的object.defineProperty的set\get)</li></ol> <h3 id="_6-浅拷贝-深拷贝"><a href="#_6-浅拷贝-深拷贝" class="header-anchor">#</a> 6. 浅拷贝 深拷贝</h3> <ol><li>浅拷贝 对原对象的引用，当你修改了某些值，原对象对应的值也会改变<br>
var obj = {
a:1;
arr:[2,3]
}
var cloneobj = clone(obj)</li></ol> <p>function clone(obj){
let newobj = {}
for(let item in obj){
if(obj.hasOwnProperty(item))  // 如果obj有item这个属性
{
newobj[item] = obj[item]
}
}
return newobj
}
newobj.arr[1]=100;
console.log(obj.arr[1])  //100</p> <div class="language- extra-class"><pre class="language-text"><code>这里遍历的只是最前排，若对象里面只是基本数据类型，那么这也算是深拷贝了，包括obj.spice() obj.contact   
但如果里面包含引用数据类型，就行不通了

2. 深拷贝 开辟一片新内存，将值拷贝过去
  - Json.parse(Json.stringify())  最简单粗暴的一种方法
  - 递归
  ```
    var obj = {
     name:'周心',
     age:22,
     BirthPlace:['中国', '江西',  宜春']
    }
    let deepobj = deepClone(obj)
    deepobj.BirthPlace[1]=&quot;湖南&quot;
    deepobj.BirthPlace[2]=&quot;长沙&quot;
    console.log(obj)  // ... 中国 江西 宜春
    console.log(deepobj)  // ... 中国 湖南 长沙


    function deepClone(obj){
      var src = obj.constructor = Array?[]:{} // 判断obj属于啥子类型，并创建该空类型

      for(let item in obj){
        if(typeof obj[item]===&quot;object&quot;){
          src[item]=deepClone(obj[item]);
        }else{
          src[item]=obj[item];
       }
      }
      return src
    }
</code></pre></div><h3 id="_7-防抖-节流"><a href="#_7-防抖-节流" class="header-anchor">#</a> 7. 防抖 节流</h3> <ol><li><p>防抖 相比于坐电梯，按了10s后电梯启动，后面来一个人按了，得等十秒，又来一个人按，再得等10s<br>
使用场景</p> <ul><li>搜索的时候，如果不设置防抖就会频繁的发送请求，增加服务器压力。<br>
无论你怎么点，点完最后一次，隔2s打印success</li></ul> <div class="language- extra-class"><pre class="language-text"><code>&lt;button id='btn'/&gt;

function success()=&gt;{
  console.log('success')
}
const debance = (fn,delay)=&gt;{
  let timer = null
  return (...args)=&gt;{
    clearTimeout(timer)
    timer = setTimeOut({
      fn.apply(this,args)
    },delay)
  }
}
const odebance = debance(success,2000)
let btn = document.getElementById('btn')
btn.addEventListener('click',odebance)
</code></pre></div></li> <li><p>节流 在打王者的时候，你疯狂的用技能，疯狂的用技能，可是CD没到你摁的再快也没什么卵用，这就是节流的原理，在高频率的触发某件事的时候，只能在一定的时间段执行一次
使用场景</p> <ul><li>滚动条滚动的时候，用户疯狂滚动，就会触发大量的函数，而用防抖完全是不明智的，这时候就要使用节流了。</li> <li>游戏</li></ul> <div class="language- extra-class"><pre class="language-text"><code>&lt;button id='btn'/&gt;

function success()=&gt;{
  console.log('success')
}
const throttle = (fn,delay)=&gt;{
  let flag = true
  return (...args)=&gt;{
    if(!flag) return 
    flag = false
    timer = setTimeOut({
      fn.apply(this)
      flag = true
    },delay)
  }
}
const othrottle = throttle(success,2000)
let btn = document.getElementById('btn')
btn.addEventListener('click',othrottle)
</code></pre></div></li></ol> <h3 id="_8-数组去重"><a href="#_8-数组去重" class="header-anchor">#</a> 8. 数组去重</h3> <ul><li>indexof 寻找索引，如果有，返回第一次出现的索引，如果没有，返回-1</li> <li>includes 是否包含 是返回true 否则返回false</li></ul> <ol><li>es6的filter 第一眼见到这个函数我就觉得秒呀，因为返回的是第一项的下标，就比如2，返回第一个2的下标1，然后第一个2的下标是2，说明重复了</li></ol> <div class="language- extra-class"><pre class="language-text"><code>  let arr = [1, 2, 2, 3, 4, 5, 6, 4]
  function getarr(arr){
  let result = arr.filter((item,index) =&gt;{
    return arr.indexOf(item) == index
  })
   console.log(result) //1 2 3 4 5 6
  }
  getarr(arr)
</code></pre></div><ol start="2"><li>es6的set，里面的元素必须独一无二，但是返回的不是数组,所以得转换一下</li></ol> <div class="language- extra-class"><pre class="language-text"><code>  let arr = [1, 2, 2, 3, 4, 5, 6, 4]
  function getarr(){
   let result = Array.from(new Set(arr))
   &lt;!-- let result = [...new Set(arr)] --&gt;
   console.log(result) //1 2 3 4 5 6
  }
  getarr()
</code></pre></div><ol start="3"><li>创建一个新数组，然后循环，把没有得push进去</li></ol> <div class="language- extra-class"><pre class="language-text"><code>  let arr = [1, 2, 2, 3, 4, 5, 6, 4]
  function getarr(){
    let result = []
    arr.forEach(item=&gt;{
     if(result.indexOf(item) == -1)
     result.push(item)
   })
   console.log(result)
  }
  getarr()
</code></pre></div><ol start="4"><li>es6的reduce reduce有俩参数 第一个是前面返回的结果</li></ol> <div class="language- extra-class"><pre class="language-text"><code>let arr = [1, 2, 2, 3, 4, 5, 6, 4]
function getarr(){
    let result =arr.reduce((pre,item) =&gt;{
      return pre.includes(item)? pre:[...pre,item]
    },[])
      console.log(result)
          
  }
  getarr()
</code></pre></div><ol start="5"><li>排序</li></ol> <div class="language- extra-class"><pre class="language-text"><code>let arr = [1, 2, 2, 3, 4, 5, 6, 4]
function getarr(){
  let result = []
  let temp = arr.sort()
  for(let i = 0; i&lt;temp.length; i++){
    if(temp[i]!=temp[i+1]){
      result.push(temp[i])
    }
  }
  console.log(result)
}
getarr()
</code></pre></div></div> <footer class="page-edit"><!----> <!----></footer> <!----> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.989c535c.js" defer></script><script src="/assets/js/2.7ff8fc86.js" defer></script><script src="/assets/js/7.787c1541.js" defer></script>
  </body>
</html>
